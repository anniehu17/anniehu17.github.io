<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Multiplication Optimizations Visualization</title>
    <style>
        :root {
            --uchu-pink-1: oklch(95.8% 0.023 354.27);
            --uchu-pink-2: oklch(92.14% 0.046 352.31);
            --uchu-pink-3: oklch(88.9% 0.066 354.39);
            --uchu-pink-4: oklch(85.43% 0.09 354.1);
            --uchu-pink-5: oklch(82.23% 0.112 355.33);
            --uchu-pink-6: oklch(78.29% 0.135 354.28);
            --uchu-pink-7: oklch(73.65% 0.155 354.15);
            --uchu-pink-8: oklch(67.25% 0.173 353.83);
            --uchu-pink-9: oklch(59.58% 0.19 353.47);
        }

        body {
            font-family: monospace;
            line-height: 1.6;
            color: #2d3748;
            background: #f7fafc;
            margin: 20px;
            max-width: none;
        }

        h1 {
            font-size: 2em;
            margin-bottom: 0.5em;
            color: var(--uchu-pink-7);
        }

        h2 {
            color: #4a5568;
            margin: 1em 0 0.5em 0;
        }

        h3, h4 {
            color: #2d3748;
            margin: 0.8em 0 0.3em 0;
        }

        .optimization {
            margin-bottom: 2em;
            border: 1px solid #e2e8f0;
            background: #ffffff;
        }

        .optimization-header {
            background: var(--uchu-pink-3);
            padding: 1em;
            border-bottom: 1px solid #e2e8f0;
        }

        .optimization-content {
            padding: 1em;
        }


        .explanation {
            background: #f7fafc;
            padding: 1em;
            border-left: 3px solid var(--uchu-pink-5);
            margin-bottom: 1em;
        }

        .visualization {
            background: #f7fafc;
            padding: 1em;
            min-height: 200px;
        }

        .matrix {
            display: inline-block;
            margin: 10px;
            border: 2px solid #4a5568;
        }

        .matrix-row {
            display: flex;
        }

        .matrix-cell {
            width: 40px;
            height: 40px;
            border: 1px solid #cbd5e0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            background: #ffffff;
        }

        .highlight {
            background: var(--uchu-pink-7) !important;
            color: var(--uchu-pink-1);
        }

        .highlight-blue {
            background: var(--uchu-pink-6) !important;
            color: var(--uchu-pink-1);
        }

        .highlight-green {
            background: var(--uchu-pink-5) !important;
            color: var(--uchu-pink-1);
        }

        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 1em;
            font-family: monospace;
            overflow-x: auto;
            margin: 1em 0;
            border: 1px solid #4a5568;
        }

        .performance-chart {
            background: #ffffff;
            padding: 1em;
            margin: 1em 0;
            border: 1px solid #e2e8f0;
        }

        .bar-chart {
            display: flex;
            align-items: end;
            height: 150px;
            margin: 1em 0;
        }

        .bar {
            flex: 1;
            margin: 0 3px;
            background: #4a5568;
            position: relative;
        }

        .bar-label {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            text-align: center;
            width: 80px;
        }

        .animation-controls {
            margin: 1em 0;
            background: #f7fafc;
            padding: 1em;
            border: 1px solid #e2e8f0;
        }

        .control-group {
            margin: 0.5em 0;
            display: inline-block;
            margin-right: 1em;
        }

        .control-group label {
            display: block;
            margin-bottom: 0.3em;
        }

        .control-group input, .control-group select {
            padding: 0.3em;
            border: 1px solid #cbd5e0;
            font-size: 12px;
            background: #ffffff;
            color: #2d3748;
        }

        .btn {
            background: var(--uchu-pink-6);
            color: #ffffff;
            border: 1px solid var(--uchu-pink-7);
            padding: 0.5em 1em;
            cursor: pointer;
            font-size: 12px;
            margin: 0.3em;
            font-family: monospace;
        }

        .btn:hover {
            background: var(--uchu-pink-7);
        }

        .btn:disabled {
            background: #a0aec0;
            cursor: not-allowed;
        }

        .header {
            background: var(--uchu-pink-2);
            padding: 1em;
            margin-bottom: 2em;
            border-radius: 8px;
            border: 1px solid var(--uchu-pink-4);
        }

        .home-link {
            text-decoration: none;
            color: var(--uchu-pink-8);
            font-weight: bold;
            font-size: 1.1em;
        }

        .home-link:hover {
            color: var(--uchu-pink-9);
            text-decoration: underline;
        }

        .simd-visualization {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 20px 0;
        }

        .vector-register {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .vector-box {
            display: flex;
            border: 2px solid #4a5568;
            border-radius: 5px;
            margin: 5px 0;
        }

        .vector-element {
            width: 50px;
            height: 40px;
            border: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #ffffff;
            font-size: 12px;
        }

        .thread-visualization {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 20px 0;
        }

        .thread-block {
            background: #4facfe;
            color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            position: relative;
            animation: threadPulse 2s infinite;
        }

        @keyframes threadPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .memory-layout {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
        }

        .memory-row {
            display: flex;
            gap: 2px;
        }

        .memory-block {
            width: 30px;
            height: 30px;
            border: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            background: #ffffff;
        }

    </style>
</head>
<body>
    <div class="header">
        <a href="index.html" class="home-link">Home</a>
    </div>
    
    <h1>Matrix Multiplication Optimizations</h1>
    <p>Interactive visualization of performance optimization techniques</p>

        <!-- Naive Implementation -->
        <div class="optimization">
            <div class="optimization-header">
                <h2>1. Naive Implementation (Baseline)</h2>
            </div>
            <div class="optimization-content">
                <div class="explanation">
                        <h3>The Standard Triple-Nested Loop</h3>
                        <p>Most straightforward implementation using three nested loops.</p>
                        
                        <h4>Key Characteristics:</h4>
                        <ul>
                            <li>O(n³) time complexity</li>
                            <li>Poor cache locality for matrix B</li>
                            <li>Sequential memory access pattern</li>
                        </ul>
                </div>
                <div class="visualization">
                        <h4>Memory Access Pattern</h4>
                        <div id="naive-viz"></div>
                        <div class="animation-controls">
                            <div class="control-group">
                                <label>Matrix Size</label>
                                <select id="naive-size" onchange="updateMatrixSize('naive')">
                                    <option value="3">3x3</option>
                                    <option value="4" selected>4x4</option>
                                    <option value="5">5x5</option>
                                    <option value="6">6x6</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label>Speed (ms)</label>
                                <input type="range" id="naive-speed" min="50" max="1000" value="200" onchange="updateSpeed('naive')">
                                <span id="naive-speed-value">200ms</span>
                            </div>
                            <br>
                            <button class="btn" onclick="startAnimation('naive')" id="naive-start">Start Animation</button>
                            <button class="btn" onclick="stopAnimation('naive')" id="naive-stop" disabled>Stop Animation</button>
                        </div>
                </div>
                
                <div class="code-block">
<pre>for (size_t i = 0; i &lt; size; i++) {
    for (size_t j = 0; j &lt; size; j++) {
        float acc = 0.0;
        for (size_t k = 0; k &lt; size; k++) {
            acc += A[i * size + k] * B[k * size + j];  // Poor cache locality for B
        }
        C[i * size + j] = acc;
    }
}</pre>
                </div>
            </div>
        </div>

        <!-- Loop Unrolling -->
        <div class="optimization">
            <div class="optimization-header">
                <h2>2. Loop Unrolling</h2>
            </div>
            <div class="optimization-content">
                <div class="explanation">
                        <h3>Manual Loop Unrolling (4x)</h3>
                        <p>Reduces loop control overhead by processing multiple iterations at once.</p>
                        
                        <h4>Benefits:</h4>
                        <ul>
                            <li>Reduces loop control overhead</li>
                            <li>Increases instruction-level parallelism</li>
                            <li>Better CPU pipeline utilization</li>
                        </ul>
                </div>
                <div class="visualization">
                        <h4>Unrolled vs Normal Loop</h4>
                        <div id="unroll-viz"></div>
                        <div class="animation-controls">
                            <div class="control-group">
                                <label>Speed (ms)</label>
                                <input type="range" id="unroll-speed" min="100" max="1000" value="300" onchange="updateSpeed('unroll')">
                                <span id="unroll-speed-value">300ms</span>
                            </div>
                            <br>
                            <button class="btn" onclick="startAnimation('unroll')" id="unroll-start">Start Animation</button>
                            <button class="btn" onclick="stopAnimation('unroll')" id="unroll-stop" disabled>Stop Animation</button>
                        </div>
                </div>
                
                <div class="code-block">
<pre>for (register int k = 0; k &lt; (size &amp; ~3); ) {
    acc += A[i * size + k] * B[k * size + j];  // Iteration 1
    k += 1;
    acc += A[i * size + k] * B[k * size + j];  // Iteration 2
    k += 1;
    acc += A[i * size + k] * B[k * size + j];  // Iteration 3
    k += 1;
    acc += A[i * size + k] * B[k * size + j];  // Iteration 4
    k += 1;
}
// Handle remainder
for (register int k = (size &amp; ~3); k &lt; size; k++) {
    acc += A[i * size + k] * B[k * size + j];
}</pre>
                </div>
            </div>
        </div>

        <!-- Matrix Transposition -->
        <div class="optimization">
            <div class="optimization-header">
                <h2>3. Matrix Transposition for Cache Optimization</h2>
            </div>
            <div class="optimization-content">
                <div class="explanation">
                        <h3>Improving Cache Locality</h3>
                        <p>Transposing matrix B converts column-wise access to row-wise access.</p>
                        
                        <h4>Benefits:</h4>
                        <ul>
                            <li>Sequential memory access for both matrices</li>
                            <li>Better cache line utilization</li>
                            <li>Reduced cache misses</li>
                            <li>~2-4x speedup on large matrices</li>
                        </ul>
                </div>
                <div class="visualization">
                        <h4>Memory Access Pattern Comparison</h4>
                        <div id="transpose-viz"></div>
                        <div class="animation-controls">
                            <div class="control-group">
                                <label>Speed (ms)</label>
                                <input type="range" id="transpose-speed" min="200" max="1000" value="400" onchange="updateSpeed('transpose')">
                                <span id="transpose-speed-value">400ms</span>
                            </div>
                            <br>
                            <button class="btn" onclick="startAnimation('transpose')" id="transpose-start">Start Animation</button>
                            <button class="btn" onclick="stopAnimation('transpose')" id="transpose-stop" disabled>Stop Animation</button>
                        </div>
                </div>
                
                <div class="code-block">
<pre>// Transpose B matrix once
float* b_t = transpose(B, size);

for (int i = 0; i &lt; size; i++) {
    for (int j = 0; j &lt; size; j++) {
        float *a_row = &amp;A[i * size];           // Row-wise access
        float *b_transposed_row = &amp;b_t[j * size]; // Now also row-wise!
        
        float acc = 0;
        for (int k = 0; k &lt; size; k++) {
            acc += a_row[k] * b_transposed_row[k]; // Both sequential!
        }
        C[i * size + j] = acc;
    }
}</pre>
                </div>
            </div>
        </div>

        <!-- Threading -->
        <div class="optimization">
            <div class="optimization-header">
                <h2>4. Multi-threading Parallelization</h2>
            </div>
            <div class="optimization-content">
                <div class="explanation">
                        <h3>Parallel Processing with pthreads</h3>
                        <p>Distributes the workload across multiple CPU cores by having each thread process different rows of the result matrix.</p>
                        
                        <h4>Implementation Strategy:</h4>
                        <ul>
                            <li>Each thread processes every nth row (where n = thread count)</li>
                            <li>Thread i processes rows: i, i+n, i+2n, ...</li>
                            <li>Good load balancing across cores</li>
                            <li>Minimal synchronization overhead</li>
                        </ul>
                        
                        <h4>Scalability:</h4>
                        <ul>
                            <li>Near-linear speedup with core count</li>
                            <li>Limited by memory bandwidth</li>
                        </ul>
                </div>
                <div class="visualization">
                        <h4>Thread Work Distribution</h4>
                        <div id="thread-viz"></div>
                        <div class="animation-controls">
                            <div class="control-group">
                                <label>Speed (ms)</label>
                                <input type="range" id="thread-speed" min="300" max="1500" value="500" onchange="updateSpeed('thread')">
                                <span id="thread-speed-value">500ms</span>
                            </div>
                            <br>
                            <button class="btn" onclick="startAnimation('thread')" id="thread-start">Start Animation</button>
                            <button class="btn" onclick="stopAnimation('thread')" id="thread-stop" disabled>Stop Animation</button>
                        </div>
                </div>
                
                <div class="code-block">
<pre>void *matrix_multiply_thread(void *user) {
    Worker *worker = (Worker *) user;
    int workerIdx = worker-&gt;workerIdx;
    int thread_count = worker-&gt;thread_count;
    
    // Each thread processes every nth row
    for (int i = workerIdx; i &lt; size; i += thread_count) {
        for (int j = 0; j &lt; size; j++) {
            // Compute C[i][j]
            float acc = 0;
            for (int k = 0; k &lt; size; k++) {
                acc += A[i * size + k] * B_transposed[j * size + k];
            }
            C[i * size + j] = acc;
        }
    }
    return NULL;
}</pre>
                </div>
            </div>
        </div>

        <!-- SIMD Vectorization -->
        <div class="optimization">
            <div class="optimization-header">
                <h2>5. SIMD Vectorization (ARM NEON)</h2>
            </div>
            <div class="optimization-content">
                <div class="explanation">
                        <h3>Vector Processing with NEON Intrinsics</h3>
                        <p>Uses ARM NEON SIMD instructions to process 4 floating-point numbers simultaneously, dramatically increasing computational throughput.</p>
                        
                        <h4>SIMD Operations:</h4>
                        <ul>
                            <li>4x 32-bit floats processed per instruction</li>
                            <li>Fused multiply-add (FMA) operations</li>
                            <li>Vector load/store operations</li>
                            <li>Horizontal reduction for final sum</li>
                        </ul>
                        
                        <h4>Performance Gains:</h4>
                        <ul>
                            <li>~4x theoretical speedup</li>
                            <li>Actual gains depend on memory bandwidth</li>
                            <li>Works best with aligned data</li>
                        </ul>
                </div>
                <div class="visualization">
                        <h4>SIMD Vector Operations</h4>
                        <div id="simd-viz"></div>
                        <div class="animation-controls">
                            <div class="control-group">
                                <label>Speed (ms)</label>
                                <input type="range" id="simd-speed" min="200" max="1000" value="300" onchange="updateSpeed('simd')">
                                <span id="simd-speed-value">300ms</span>
                            </div>
                            <br>
                            <button class="btn" onclick="startAnimation('simd')" id="simd-start">Start Animation</button>
                            <button class="btn" onclick="stopAnimation('simd')" id="simd-stop" disabled>Stop Animation</button>
                        </div>
                </div>
                
                <div class="code-block">
<pre>float32x4_t acc = vdupq_n_f32(0);  // Zero vector accumulator

for (int k = 0; k &lt; (size &amp; ~3); k += 4) {
    // Load 4 floats from A and B simultaneously
    float32x4_t a_reg = vld1q_f32(&amp;a_row[k]);
    float32x4_t b_reg = vld1q_f32(&amp;b_transposed_row[k]);
    
    // Fused multiply-add: acc = acc + (a_reg * b_reg)
    acc = vfmaq_f32(acc, a_reg, b_reg);
}

// Horizontal sum to get final result
float sum = vaddvq_f32(acc);

// Handle remainder elements
for (int k = (size &amp; ~3); k &lt; size; k++) {
    sum += a_row[k] * b_transposed_row[k];
}</pre>
                </div>
            </div>
        </div>

        <!-- Inline Assembly -->
        <div class="optimization">
            <div class="optimization-header">
                <h2>6. Hand-Optimized Inline Assembly</h2>
            </div>
            <div class="optimization-content">
                <div class="explanation">
                        <h3>Maximum Performance with Assembly</h3>
                        <p>Hand-written ARM assembly code provides ultimate control over instruction scheduling, register allocation, and memory access patterns.</p>
                        
                        <h4>Assembly Optimizations:</h4>
                        <ul>
                            <li>Direct NEON register manipulation</li>
                            <li>Optimal instruction scheduling</li>
                            <li>Minimized memory latency</li>
                            <li>Precise register allocation</li>
                        </ul>
                        
                        <h4>Key Instructions:</h4>
                        <ul>
                            <li><code>LD1</code> - Vector load with auto-increment</li>
                            <li><code>FMLA</code> - Fused multiply-add</li>
                            <li><code>FADDP</code> - Pairwise floating-point add</li>
                            <li><code>FMOV</code> - Move from vector to general register</li>
                        </ul>
                </div>
                <div class="visualization">
                        <h4>Assembly Instruction Pipeline</h4>
                        <div id="asm-viz"></div>
                        <div class="animation-controls">
                            <div class="control-group">
                                <label>Speed (ms)</label>
                                <input type="range" id="asm-speed" min="150" max="800" value="250" onchange="updateSpeed('asm')">
                                <span id="asm-speed-value">250ms</span>
                            </div>
                            <br>
                            <button class="btn" onclick="startAnimation('asm')" id="asm-start">Start Animation</button>
                            <button class="btn" onclick="stopAnimation('asm')" id="asm-stop" disabled>Stop Animation</button>
                        </div>
                </div>
                
                <div class="code-block">
<pre>__asm__ volatile(
    "DUP v0.4s, wzr\n"              // Zero accumulator vector
    "mov x3, %[limit]\n"            // Load loop limit
    "1:\n"                          // Loop label
    
    "LD1 {v1.4s}, [%[a_ptr]], #16\n"  // Load 4 floats from A, increment pointer
    "LD1 {v2.4s}, [%[b_ptr]], #16\n"  // Load 4 floats from B, increment pointer
    "FMLA v0.4s, v1.4s, v2.4s\n"      // acc += A * B (vectorized)
    
    "sub x3, x3, #4\n"              // Decrement counter
    "cbnz x3, 1b\n"                 // Branch if not zero
    
    // Horizontal reduction
    "FADDP v0.4s, v0.4s, v0.4s\n"   // Pairwise add
    "FADDP s0, v0.2s\n"             // Final sum
    "FMOV %w[output], s0\n"         // Move to output register
    
    : [output] "=r" (sum), [b_ptr] "+r" (b_transposed_row)
    : [limit] "r" ((size_t)(size &amp; ~3)), [a_ptr] "r" (a_row)
    : "v0", "v1", "v2", "x3"
);</pre>
                </div>
            </div>
        </div>

        <!-- Performance Comparison -->
        <div class="optimization">
            <div class="optimization-header">
                <h2>7. Performance Comparison</h2>
            </div>
            <div class="optimization-content">
                <div class="performance-chart">
                    <h3>Relative Performance (Speedup vs Naive)</h3>
                    <div class="bar-chart" id="performance-chart"></div>
                </div>
                
                <div class="explanation">
                    <h3>Performance Analysis Summary</h3>
                    <p>Each optimization technique builds upon the previous ones, creating a cumulative performance improvement:</p>
                    
                    <h4>Optimization Stack:</h4>
                    <ol>
                        <li><strong>Naive</strong> - Baseline performance</li>
                        <li><strong>Loop Unrolling</strong> - ~1.5x improvement through reduced loop overhead</li>
                        <li><strong>Matrix Transpose</strong> - ~3x improvement through cache optimization</li>
                        <li><strong>Threading</strong> - ~8x improvement through parallel processing</li>
                        <li><strong>SIMD</strong> - ~15x improvement through vector operations</li>
                        <li><strong>Assembly</strong> - ~20x improvement through hand optimization</li>
                    </ol>
                    
                    <h4>Key Insights:</h4>
                    <ul>
                        <li>Cache optimization provides the biggest single improvement</li>
                        <li>Parallelization scales well with core count</li>
                        <li>SIMD provides significant computational speedup</li>
                        <li>Assembly optimization yields the final performance edge</li>
                    </ul>
                </div>
            </div>
        </div>

    <script>
        // Global animation state
        let animationStates = {};
        let animationSpeeds = {
            naive: 200,
            unroll: 300,
            transpose: 400,
            thread: 500,
            simd: 300,
            asm: 250
        };


        function updateMatrixSize(type) {
            const sizeSelect = document.getElementById(type + '-size');
            const size = parseInt(sizeSelect.value);
            if (type === 'naive') {
                createMatrix(size, 'naive-viz', 'Matrix Access Pattern');
            }
        }

        function updateSpeed(type) {
            const speedSlider = document.getElementById(type + '-speed');
            const speedValue = document.getElementById(type + '-speed-value');
            animationSpeeds[type] = parseInt(speedSlider.value);
            speedValue.textContent = speedSlider.value + 'ms';
        }

        function startAnimation(type) {
            const startBtn = document.getElementById(type + '-start');
            const stopBtn = document.getElementById(type + '-stop');
            
            startBtn.disabled = true;
            stopBtn.disabled = false;
            
            animationStates[type] = { running: true, step: 0 };
            
            if (type === 'naive') {
                animateNaiveLoop();
            } else if (type === 'unroll') {
                animateUnrollLoop();
            } else if (type === 'transpose') {
                animateTransposeLoop();
            } else if (type === 'thread') {
                animateThreadLoop();
            } else if (type === 'simd') {
                animateSIMDLoop();
            } else if (type === 'asm') {
                animateAssemblyLoop();
            }
        }

        function stopAnimation(type) {
            const startBtn = document.getElementById(type + '-start');
            const stopBtn = document.getElementById(type + '-stop');
            
            startBtn.disabled = false;
            stopBtn.disabled = true;
            
            if (animationStates[type]) {
                animationStates[type].running = false;
            }
        }

        function createMatrix(size, containerId, label = '') {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            container.innerHTML = '';
            if (label) {
                const labelEl = document.createElement('div');
                labelEl.textContent = label;
                labelEl.style.marginBottom = '10px';
                labelEl.style.fontWeight = 'bold';
                container.appendChild(labelEl);
            }
            
            const matrix = document.createElement('div');
            matrix.className = 'matrix';
            
            for (let i = 0; i < size; i++) {
                const row = document.createElement('div');
                row.className = 'matrix-row';
                for (let j = 0; j < size; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'matrix-cell';
                    cell.textContent = Math.floor(Math.random() * 10);
                    cell.id = `${containerId}-${i}-${j}`;
                    row.appendChild(cell);
                }
                matrix.appendChild(row);
            }
            container.appendChild(matrix);
        }

        function animateNaive() {
            const sizeSelect = document.getElementById('naive-size');
            const size = sizeSelect ? parseInt(sizeSelect.value) : 4;
            createMatrix(size, 'naive-viz', 'Matrix Access Pattern');
            startAnimation('naive');
        }

        function animateNaiveLoop() {
            const sizeSelect = document.getElementById('naive-size');
            const size = sizeSelect ? parseInt(sizeSelect.value) : 4;
            
            function animate() {
                if (!animationStates.naive || !animationStates.naive.running) return;
                
                // Clear previous highlights
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        const cell = document.getElementById(`naive-viz-${i}-${j}`);
                        if (cell) cell.className = 'matrix-cell';
                    }
                }
                
                const step = animationStates.naive.step;
                const i = Math.floor(step / (size * size)) % size;
                const j = Math.floor(step / size) % size;
                const k = step % size;
                
                // Highlight current access
                const cellA = document.getElementById(`naive-viz-${i}-${k}`);
                const cellB = document.getElementById(`naive-viz-${k}-${j}`);
                
                if (cellA) cellA.className = 'matrix-cell highlight';
                if (cellB) cellB.className = 'matrix-cell highlight-blue';
                
                animationStates.naive.step++;
                if (animationStates.naive.step >= size * size * size) {
                    animationStates.naive.step = 0; // Loop animation
                }
                
                if (animationStates.naive.running) {
                    setTimeout(animate, animationSpeeds.naive);
                }
            }
            animate();
        }

        function animateUnroll() {
            const container = document.getElementById('unroll-viz');
            container.innerHTML = `
                <div style="display: flex; justify-content: space-around;">
                    <div style="text-align: center;">
                        <h4>Normal Loop</h4>
                        <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 10px;">
                            <div style="margin: 5px; padding: 8px; background: #ff6b6b; color: white; border-radius: 4px;">Loop overhead</div>
                            <div style="margin: 5px; padding: 8px; background: #4ecdc4; color: white; border-radius: 4px;">Computation</div>
                            <div style="margin: 5px; padding: 8px; background: #ff6b6b; color: white; border-radius: 4px;">Loop overhead</div>
                            <div style="margin: 5px; padding: 8px; background: #4ecdc4; color: white; border-radius: 4px;">Computation</div>
                            <div style="margin: 5px; padding: 8px; background: #ff6b6b; color: white; border-radius: 4px;">Loop overhead</div>
                            <div style="margin: 5px; padding: 8px; background: #4ecdc4; color: white; border-radius: 4px;">Computation</div>
                        </div>
                    </div>
                    <div style="text-align: center;">
                        <h4>Unrolled Loop (4x)</h4>
                        <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 10px;">
                            <div style="margin: 5px; padding: 8px; background: #ff6b6b; color: white; border-radius: 4px;">Loop overhead</div>
                            <div style="margin: 5px; padding: 8px; background: #4ecdc4; color: white; border-radius: 4px;">Computation 1</div>
                            <div style="margin: 5px; padding: 8px; background: #4ecdc4; color: white; border-radius: 4px;">Computation 2</div>
                            <div style="margin: 5px; padding: 8px; background: #4ecdc4; color: white; border-radius: 4px;">Computation 3</div>
                            <div style="margin: 5px; padding: 8px; background: #4ecdc4; color: white; border-radius: 4px;">Computation 4</div>
                        </div>
                </div>
                <p style="text-align: center; margin-top: 20px; font-weight: bold; color: #667eea;">
                    75% reduction in loop overhead!
                </p>
            `;
        }

        function animateTranspose() {
            const container = document.getElementById('transpose-viz');
            container.innerHTML = `
                <div style="display: flex; justify-content: space-around; align-items: center;">
                    <div style="text-align: center;">
                        <h4>Before Transpose</h4>
                        <div style="margin: 10px;">
                            <div style="background: #ff6b6b; color: white; padding: 5px; margin: 2px; border-radius: 4px;">A[0,0] × B[0,0] ✓</div>
                            <div style="background: #ffcc6b; color: white; padding: 5px; margin: 2px; border-radius: 4px;">A[0,1] × B[1,0] (cache miss)</div>
                            <div style="background: #ffcc6b; color: white; padding: 5px; margin: 2px; border-radius: 4px;">A[0,2] × B[2,0] (cache miss)</div>
                            <div style="background: #ffcc6b; color: white; padding: 5px; margin: 2px; border-radius: 4px;">A[0,3] × B[3,0] (cache miss)</div>
                        </div>
                        <p style="color: #e74c3c; font-weight: bold;">Poor cache locality</p>
                    </div>
                    <div style="font-size: 2em; color: #667eea;">→</div>
                    <div style="text-align: center;">
                        <h4>After Transpose</h4>
                        <div style="margin: 10px;">
                            <div style="background: #4ecdc4; color: white; padding: 5px; margin: 2px; border-radius: 4px;">A[0,0] × B_T[0,0] ✓</div>
                            <div style="background: #4ecdc4; color: white; padding: 5px; margin: 2px; border-radius: 4px;">A[0,1] × B_T[0,1] ✓</div>
                            <div style="background: #4ecdc4; color: white; padding: 5px; margin: 2px; border-radius: 4px;">A[0,2] × B_T[0,2] ✓</div>
                            <div style="background: #4ecdc4; color: white; padding: 5px; margin: 2px; border-radius: 4px;">A[0,3] × B_T[0,3] ✓</div>
                        </div>
                        <p style="color: #27ae60; font-weight: bold;">Sequential access</p>
                </div>
            `;
        }

        function animateThreads() {
            const container = document.getElementById('thread-viz');
            container.innerHTML = '';
            
            const threadColors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4'];
            const threadNames = ['Thread 0', 'Thread 1', 'Thread 2', 'Thread 3'];
            
            for (let i = 0; i < 4; i++) {
                const thread = document.createElement('div');
                thread.className = 'thread-block';
                thread.style.background = threadColors[i];
                thread.style.animationDelay = `${i * 0.2}s`;
                thread.innerHTML = `
                    <strong>${threadNames[i]}</strong><br>
                    Rows: ${i}, ${i+4}, ${i+8}...
                `;
                container.appendChild(thread);
            }
        }

        function animateSIMD() {
            const container = document.getElementById('simd-viz');
            container.innerHTML = `
                <div class="simd-visualization">
                    <div class="vector-register">
                        <h4>Vector A</h4>
                        <div class="vector-box">
                            <div class="vector-element" style="background: #ff6b6b; color: white;">1.5</div>
                            <div class="vector-element" style="background: #ff6b6b; color: white;">2.3</div>
                            <div class="vector-element" style="background: #ff6b6b; color: white;">0.8</div>
                            <div class="vector-element" style="background: #ff6b6b; color: white;">3.1</div>
                        </div>
                    </div>
                    <div style="font-size: 2em; color: #667eea;">×</div>
                    <div class="vector-register">
                        <h4>Vector B</h4>
                        <div class="vector-box">
                            <div class="vector-element" style="background: #4ecdc4; color: white;">0.9</div>
                            <div class="vector-element" style="background: #4ecdc4; color: white;">1.7</div>
                            <div class="vector-element" style="background: #4ecdc4; color: white;">2.4</div>
                            <div class="vector-element" style="background: #4ecdc4; color: white;">0.6</div>
                        </div>
                    </div>
                    <div style="font-size: 2em; color: #667eea;">=</div>
                    <div class="vector-register">
                        <h4>Result</h4>
                        <div class="vector-box">
                            <div class="vector-element" style="background: #45b7d1; color: white;">1.35</div>
                            <div class="vector-element" style="background: #45b7d1; color: white;">3.91</div>
                            <div class="vector-element" style="background: #45b7d1; color: white;">1.92</div>
                            <div class="vector-element" style="background: #45b7d1; color: white;">1.86</div>
                        </div>
                </div>
                <p style="text-align: center; margin-top: 20px; font-weight: bold; color: #667eea;">
                    4 operations executed simultaneously with FMLA instruction
                </p>
            `;
        }

        function animateAssembly() {
            const container = document.getElementById('asm-viz');
            container.innerHTML = `
                <div style="background: #2d3748; color: #e2e8f0; padding: 20px; border-radius: 10px; font-family: monospace;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 20px;">
                        <div style="flex: 1; margin: 0 10px;">
                            <h4 style="color: #4facfe; margin-bottom: 10px;">Pipeline Stage 1</h4>
                            <div style="background: #4a5568; padding: 10px; border-radius: 5px; margin: 5px 0;">LD1 {v1.4s}, [A_ptr]</div>
                            <div style="background: #4a5568; padding: 10px; border-radius: 5px; margin: 5px 0;">LD1 {v2.4s}, [B_ptr]</div>
                        </div>
                        <div style="flex: 1; margin: 0 10px;">
                            <h4 style="color: #4facfe; margin-bottom: 10px;">Pipeline Stage 2</h4>
                            <div style="background: #4a5568; padding: 10px; border-radius: 5px; margin: 5px 0;">FMLA v0.4s, v1.4s, v2.4s</div>
                        </div>
                        <div style="flex: 1; margin: 0 10px;">
                            <h4 style="color: #4facfe; margin-bottom: 10px;">Pipeline Stage 3</h4>
                            <div style="background: #4a5568; padding: 10px; border-radius: 5px; margin: 5px 0;">FADDP v0.4s, v0.4s, v0.4s</div>
                            <div style="background: #4a5568; padding: 10px; border-radius: 5px; margin: 5px 0;">FADDP s0, v0.2s</div>
                        </div>
                    </div>
                    <p style="text-align: center; color: #81e6d9;">
                        Optimal instruction scheduling with minimal latency
                    </p>
                </div>
            `;
        }

        function createPerformanceChart() {
            const container = document.getElementById('performance-chart');
            const data = [
                {name: 'Naive', speedup: 1, color: '#ff6b6b'},
                {name: 'Loop Unroll', speedup: 1.5, color: '#ffa726'},
                {name: 'Transpose', speedup: 3.2, color: '#ffeb3b'},
                {name: 'Threading', speedup: 8.1, color: '#4caf50'},
                {name: 'SIMD', speedup: 15.3, color: '#2196f3'},
                {name: 'Assembly', speedup: 20.7, color: '#9c27b0'}
            ];
            
            container.innerHTML = '';
            
            data.forEach(item => {
                const bar = document.createElement('div');
                bar.className = 'bar';
                bar.style.height = `${(item.speedup / 25) * 100}%`;
                bar.style.background = `linear-gradient(to top, ${item.color}, ${item.color}dd)`;
                
                const label = document.createElement('div');
                label.className = 'bar-label';
                label.innerHTML = `${item.name}<br>${item.speedup}x`;
                
                bar.appendChild(label);
                container.appendChild(bar);
            });
        }

        function animateUnrollLoop() {
            animateUnroll();
        }

        function animateTransposeLoop() {
            animateTranspose();
        }

        function animateThreadLoop() {
            animateThreads();
        }

        function animateSIMDLoop() {
            animateSIMD();
        }

        function animateAssemblyLoop() {
            animateAssembly();
        }

        // Initialize visualizations
        document.addEventListener('DOMContentLoaded', function() {
            createPerformanceChart();
            animateUnroll();
            animateTranspose();
            animateThreads();
            animateSIMD();
            animateAssembly();
            
            // Initialize matrix visualization
            createMatrix(4, 'naive-viz', 'Matrix Access Pattern');
            
            // Initialize speed displays
            const speedValues = ['naive', 'unroll', 'transpose', 'thread', 'simd', 'asm'];
            speedValues.forEach(type => {
                const element = document.getElementById(type + '-speed-value');
                if (element) {
                    element.textContent = animationSpeeds[type] + 'ms';
                }
            });
        });
    </script>
</body>
</html>